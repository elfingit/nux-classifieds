'use strict'

const schema_constans = require('../lib/schema_constants')
const validator = require('validator')
const { ValidationError } = require('../api/lib/errors')
const ValidationResult = require('../api/lib/ValidationResult')

const userModel = require('../api/models/User')

class UserSchema {

  get fields() {

    let fields = new Map()

    fields.set('id', {
      type: schema_constans.AUTOGENERATED,
      store_validation: null
    })

    fields.set('email', {
      type: schema_constans.EMAIL,
      store_validation: (value) => {

        let errors = []

        let validators = []
        //is empty?
        validators.push(new Promise((resolve, reject) => {
          if (validator.isEmpty(value)) {
            errors.push({
              'message': 'validation.required',
              'code': 'email'
            })

            return reject(new ValidationError('validation.required'))
          }

          resolve(true)
        }))

        //is email?
        validators.push(new Promise((resolve, reject) => {
          if (!validator.isEmail(value)) {
            errors.push({
              'message': 'validation.bad_email',
              'code': 'email'
            })

            return reject(new ValidationError('validation.bad_email'))
          }

          resolve(true)
        }))

        //is already taken?
        validators.push(new Promise((resolve, reject) => {
          userModel.byEmail(value)
            .then((u) => {

              if (u != null) {
                errors.push({
                  'message': 'validation.email_taken',
                  'code': 'email'
                })
                return reject(new ValidationError('validation.email_taken'))
              }

              return resolve(true)

            }).catch((err) => {
              return reject(err)
            })
        }))

        Promise.all(validators)
          .then(() => {

          }).catch((err) => {

          })
      }
    })

    return fields

  }



}


module.exports = UserSchema
